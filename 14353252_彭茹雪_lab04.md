一、实验内容
1.死锁停在第几次的截图
2.产生死锁的4个必要条件
3.对上述程序产生死锁的解释
二、实验结果
1.如图所示，在第26次死锁。

2. 产生死锁的4个必要条件
1.互斥（资源独占） 
一个资源每次只能给一个进程使用 
2.不可强占（不可剥夺） 
资源申请者不能强行的从资源占有者手中夺取资源，资源只能由占有者自愿释放 
3.请求和保持（部分分配，占有申请） 
一个进程在申请新的资源的同时保持对原有资源的占有（只有这样才是动态申请，动态分配） 
4.循环等待 
存在一个进程等待队列 {P1 , P2 , … , Pn}, 其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路。
        3.对产生死锁的解释
	
 count 值在这里实现一个delay.
 count的目的是methodA 与methodB 可以同时运行，此时A、 B 同时互相申请资源,将可能死锁。
之所以会死锁，就是在多次 count 之后，A，B 同时申请对方的资源，满足了循环等待条件，此时产生死锁的四个条件满足，发生死锁。
运行代码后线程被插入到调度队列，它会调用 a.methodB(a)方法；同时，运行 java Runable 代码，run()函数会直接调用运行，调用了b.methodB(a)方法。所以a，b 会互相调用资源产生死锁条件。
        实验感想：这次实验较为简单，只要将TA给的代码抄到Deadlock.java里面保存，然后再在命令行里输入javac Deadlock.java, linux 系统Windows系统（把下面这段到记事本里，然后保存为.bat，然将批处理文件放在java程序（Deadlock.class）目录下，双击运行即可，这次实验复习了死锁发生的原因，也深入理解死锁，让我对产生死锁有更加深刻的理解。