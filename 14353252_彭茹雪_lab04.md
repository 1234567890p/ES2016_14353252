###一、实验内容

1.死锁停在第几次的截图

2.产生死锁的4个必要条件

3.对上述程序产生死锁的解释

###二、实验结果

![图片1](https://ooo.0o0.ooo/2016/11/11/5825aa75c267c.png)

####1.如图所示，在第26次死锁。

####2. 产生死锁的4个必要条件

1.互斥（资源独占） 

一个资源每次只能给一个进程使用 

2.不可强占（不可剥夺） 

资源申请者不能强行的从资源占有者手中夺取资源，资源只能由占有者自愿释放 

3.请求和保持（部分分配，占有申请） 

一个进程在申请新的资源的同时保持对原有资源的占有（只有这样才是动态申请，动态分配） 

4.循环等待 

存在一个进程等待队列 {P1 , P2 , … , Pn}, 其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路。

####3.对产生死锁的解释
	
![图片2](https://ooo.0o0.ooo/2016/11/11/5825aa75cc776.png)
![图片3](https://ooo.0o0.ooo/2016/11/11/5825aa75d1c71.png)
	
 count 值在这里实现一个delay.
 
 count的目的是methodA 与methodB 可以同时运行，此时A、 B 同时互相申请资源,将可能死锁。
 
之所以会死锁，就是在多次 count 之后，A，B 同时申请对方的资源，满足了循环等待条件，此时产生死锁的四个条件满足，发生死锁。

运行代码后线程被插入到调度队列，它会调用 a.methodB(a)方法；同时，运行 java Runable 代码，run()函数会直接调用运行，调用了b.methodB(a)方法。所以a，b 会互相调用资源产生死锁条件。

###实验感想：

这次实验较为简单，只要将TA给的代码抄到Deadlock.java里面保存，然后再在命令行里输入javac Deadlock.java, linux 系统Windows系统（把下面这段到记事本里，然后保存为.bat，然将批处理文件放在java程序（Deadlock.class）目录下，双击运行即可，这次实验复习了死锁发生的原因，也深入理解死锁，让我对产生死锁有更加深刻的理解。
